import 'dart:async';
import 'dart:typed_data';

import 'package:nfc_host_card_emulation/app_layer/validation.dart';
import 'package:nfc_host_card_emulation/app_layer/errors.dart';
import 'package:nfc_host_card_emulation/nfc_host_card_emulation_platform_interface.dart';

export 'package:nfc_host_card_emulation/app_layer/ndef_format/serializers/ndef_message_serializer.dart'
    show NdefRecordTuple, NdefMessageSerializer;
export 'package:nfc_host_card_emulation/app_layer/ndef_format/fields/ndef_record_fields.dart';
export 'package:nfc_host_card_emulation/nfc_host_card_emulation_platform_interface.dart'
    show HceTransaction, NfcState;

/// The main class for interacting with the HCE (Host Card Emulation) functionality.
///
/// This class provides methods to:
/// - Initialize the HCE service with a specific AID
/// - Manage NDEF files (create, update, delete)
/// - Monitor NFC transactions through a stream
/// - Check the device's NFC capabilities
///
/// All methods in this class can throw [HceException] with specific error codes
/// defined in [HceErrorCode].
class NfcHce {
  static NfcHostCardEmulationPlatform get _platform =>
      NfcHostCardEmulationPlatform.instance;

  /// A stream of HCE transaction events (command + response) observed by the native service.
  ///
  /// Listen to this stream to observe the raw APDU commands and the responses
  /// generated by the native state machine in real-time. This is useful for
  /// logging, debugging, or updating the UI based on NFC interactions.
  ///
  /// Example:
  /// ```dart
  /// NfcHce.stream.listen((transaction) {
  ///   print('Command: ${transaction.command}');
  ///   print('Response: ${transaction.response}');
  /// });
  /// ```
  ///
  /// The stream will emit events whenever an NFC reader interacts with the emulated card.
  /// Note that the stream needs to be listened to before initializing the HCE service.
  static Stream<HceTransaction> get stream => _platform.transactionStream;

  /// Initializes the native HCE state machine with a specific Application ID (AID).
  ///
  /// This MUST be called before any other file management methods.
  ///
  /// Parameters:
  /// - [aid]: The Application ID for the HCE service. Must be a [Uint8List]
  ///          with a length between 5 and 16 bytes, following ISO/IEC 7816-4.
  ///
  /// Throws:
  /// - [HceException] with [HceErrorCode.invalidAid] if the AID is invalid
  /// - [HceException] with [HceErrorCode.serviceNotAvailable] if HCE is not supported
  ///   or disabled on the device
  ///
  /// Example:
  /// ```dart
  /// // Standard NDEF application AID
  /// final aid = Uint8List.fromList([0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01]);
  /// try {
  ///   await NfcHce.init(aid: aid);
  /// } on HceException catch (e) {
  ///   print('HCE Error: ${e.message}');
  /// }
  /// ```
  ///
  /// Note: The initialized HCE service will handle ISO-DEP (ISO 14443-4) protocol
  /// automatically. Make sure to listen to [stream] before calling this method
  /// if you want to monitor the transactions.
  static Future<void> init({required Uint8List aid}) {
    ValidationUtils.validateAid(aid);
    return _platform.init(aid: aid);
  }

  /// Creates a new NDEF file or updates an existing one on the native side.
  ///
  /// This is the primary method for setting the content that the HCE service will expose.
  /// The file will be accessible to NFC readers through standard NDEF read operations.
  ///
  /// Parameters:
  /// - [fileId]: The 2-byte identifier for the file (e.g., 0xE104). Must follow
  ///             ISO/IEC 7816-4 file ID rules.
  /// - [records]: A list of NDEF records to write to the file. Each record must
  ///             contain at least a type and payload.
  /// - [maxFileSize]: The maximum size in bytes this file is allowed to be. This
  ///                  affects the CC file and limits future updates. Default is 2048 bytes.
  /// - [isWritable]: Whether the file should be writable by NFC readers via
  ///                 UPDATE_BINARY commands. Default is false (read-only).
  ///
  /// Throws:
  /// - [HceException] with [HceErrorCode.invalidFileId] if the file ID is invalid
  /// - [HceException] with [HceErrorCode.messageTooLarge] if the NDEF message exceeds maxFileSize
  /// - [HceException] with [HceErrorCode.invalidNdefFormat] if the NDEF records are malformed
  ///
  /// Example:
  /// ```dart
  /// final records = [
  ///   NdefRecordData(
  ///     type: 'text/plain',
  ///     payload: Uint8List.fromList(utf8.encode('Hello NFC!')),
  ///   ),
  /// ];
  ///
  /// try {
  ///   await NfcHce.addOrUpdateNdefFile(
  ///     fileId: 0xE104,  // Standard NDEF file ID
  ///     records: records,
  ///     maxFileSize: 4096,  // 4KB
  ///     isWritable: true,  // Allow updates from NFC readers
  ///   );
  /// } on HceException catch (e) {
  ///   print('Failed to create NDEF file: ${e.message}');
  /// }
  /// ```
  ///
  /// Note: Make sure to call [init] before using this method. The file will be
  /// automatically formatted according to the NFC Forum Type 4 Tag specification.
  static Future<void> addOrUpdateNdefFile({
    required int fileId,
    required List<NdefRecordData> records,
    int maxFileSize = 2048,
    bool isWritable = false,
  }) {
    ValidationUtils.validateFileId(fileId);
    ValidationUtils.validateNdefMessageSize(maxFileSize);

    if (records.isEmpty) {
      throw HceException(HceErrorCode.invalidNdefFormat,
          "NDEF message must contain at least one record");
    }

    return _platform.addOrUpdateNdefFile(
      records: records,
      fileId: fileId,
      maxFileSize: maxFileSize,
      isWritable: isWritable,
    );
  }

  /// Deletes a file from the native HCE file system.
  ///
  /// - [fileId]: The identifier of the file to delete.
  static Future<void> deleteNdefFile({required int fileId}) {
    return _platform.deleteNdefFile(fileId: fileId);
  }

  /// Removes all NDEF files, resetting the state machine to its initial empty state.
  static Future<void> clearAllFiles() {
    return _platform.clearAllFiles();
  }

  /// Checks if a file with the given ID exists in the native file system.
  static Future<bool> hasFile({required int fileId}) {
    return _platform.hasFile(fileId: fileId);
  }

  /// Checks the current state of the device's NFC adapter.
  static Future<NfcState> checkDeviceNfcState() {
    return _platform.checkDeviceNfcState();
  }
}
